
 <!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  
    <title>代码随想录-二叉树 | 放荡小李的博客</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=3, minimum-scale=1">
    
    <meta name="author" content="Jiale Li">
    
    <meta name="description" content="代码随想录-二叉树1、二叉树理论基础​    满二叉树，完全二叉树，二叉搜索树。
​    遍历方法

深度优先搜索
中序遍历
前序遍历
后序遍历


广度优先搜索
层序遍历



2、二叉树的递归遍历-144， 145， 94123456789101112131415161718192021222">
    
    
    
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/pacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/pacman.jpg">
    
    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.4.0"></head>

  <body>
    <header>
      <div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.svg" alt="放荡小李的博客" title="放荡小李的博客"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="放荡小李的博客">放荡小李的博客</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="text" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:example.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>

    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2022/04/06/代码随想录-二叉树/" title="代码随想录-二叉树" itemprop="url">代码随想录-二叉树</a>
  </h1>
  <p class="article-author">By
    
      <a href="http://example.com" title="Jiale Li">Jiale Li</a>
    </p>
  <p class="article-time">
    <time datetime="2022-04-06T01:42:39.000Z" itemprop="datePublished">2022-04-06</time>
    Updated:<time datetime="2022-04-14T04:14:13.775Z" itemprop="dateModified">2022-04-14</time>
    
  </p>
</header>
	<div class="article-content">
		
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">Contents</strong>
		<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">代码随想录-二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、二叉树理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-144%EF%BC%8C-145%EF%BC%8C-94"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、二叉树的递归遍历-144， 145， 94</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86-144%EF%BC%8C-145%EF%BC%8C-94"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、二叉树的迭代遍历-144， 145， 94</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.0.4.</span> <span class="toc-text">4、二叉树统一迭代法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-102"><span class="toc-number">1.0.5.</span> <span class="toc-text">5、二叉树层序遍历-102</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-226"><span class="toc-number">1.0.6.</span> <span class="toc-text">6、翻转二叉树-226</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-101"><span class="toc-number">1.0.7.</span> <span class="toc-text">7、对称二叉树-101</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%EF%BC%8C%E5%B0%8F%E6%B7%B1%E5%BA%A6-104"><span class="toc-number">1.0.8.</span> <span class="toc-text">8、二叉树的最大，小深度-104</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-222"><span class="toc-number">1.0.9.</span> <span class="toc-text">9、完全二叉树的节点个数-222</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-110"><span class="toc-number">1.0.10.</span> <span class="toc-text">10、平衡二叉树-110</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-257"><span class="toc-number">1.0.11.</span> <span class="toc-text">11、二叉树的所有路径-257</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C-404"><span class="toc-number">1.0.12.</span> <span class="toc-text">12、左叶子之和-404</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-513"><span class="toc-number">1.0.13.</span> <span class="toc-text">13、找树左下角的值-513</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-112"><span class="toc-number">1.0.14.</span> <span class="toc-text">14、路径总和-112</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-106"><span class="toc-number">1.0.15.</span> <span class="toc-text">15、从中序和后序构造二叉树-106</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-654"><span class="toc-number">1.0.16.</span> <span class="toc-text">16、最大二叉树-654</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-617"><span class="toc-number">1.0.17.</span> <span class="toc-text">17、合并二叉树-617</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-700"><span class="toc-number">1.0.18.</span> <span class="toc-text">18、二叉搜索树中的搜索-700</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-98"><span class="toc-number">1.0.19.</span> <span class="toc-text">19、验证二叉搜索树-98</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%81%9A%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC-530"><span class="toc-number">1.0.20.</span> <span class="toc-text">20、二叉搜索树的做小绝对值-530</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0-501"><span class="toc-number">1.0.21.</span> <span class="toc-text">21、二叉搜索树中的众数-501</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E4%BA%8C%E5%8F%89%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-236"><span class="toc-number">1.0.22.</span> <span class="toc-text">22、二叉（搜索）树的最近公共祖先-236</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-701"><span class="toc-number">1.0.23.</span> <span class="toc-text">23、二叉搜索树中的插入操作-701</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-450"><span class="toc-number">1.0.24.</span> <span class="toc-text">24、删除二叉搜索树中的节点-450</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-669"><span class="toc-number">1.0.25.</span> <span class="toc-text">25、修剪二叉搜索树-669</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%93%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-108"><span class="toc-number">1.0.26.</span> <span class="toc-text">26、有序数组专为二叉搜索树-108</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91-538"><span class="toc-number">1.0.27.</span> <span class="toc-text">27、把二叉搜索树转换为累加树-538</span></a></li></ol></li></ol></li></ol>
		</div>
		
		<h1 id="代码随想录-二叉树"><a href="#代码随想录-二叉树" class="headerlink" title="代码随想录-二叉树"></a>代码随想录-二叉树</h1><h3 id="1、二叉树理论基础"><a href="#1、二叉树理论基础" class="headerlink" title="1、二叉树理论基础"></a>1、二叉树理论基础</h3><p>​    满二叉树，完全二叉树，二叉搜索树。</p>
<p>​    遍历方法</p>
<ul>
<li>深度优先搜索<ul>
<li>中序遍历</li>
<li>前序遍历</li>
<li>后序遍历</li>
</ul>
</li>
<li>广度优先搜索<ul>
<li>层序遍历</li>
</ul>
</li>
</ul>
<h3 id="2、二叉树的递归遍历-144，-145，-94"><a href="#2、二叉树的递归遍历-144，-145，-94" class="headerlink" title="2、二叉树的递归遍历-144， 145， 94"></a>2、二叉树的递归遍历-144， 145， 94</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rev</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            res.append(root.val)</span><br><span class="line">            rev(root.left)</span><br><span class="line">            rev(root.right)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        rev(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rev</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            rev(root.left)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">            rev(root.right)</span><br><span class="line"></span><br><span class="line">        rev(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 后续遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">rev</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            rev(root.left)</span><br><span class="line">            rev(root.right)</span><br><span class="line">            res.append(root.val)</span><br><span class="line">        rev(root)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>



<h3 id="3、二叉树的迭代遍历-144，-145，-94"><a href="#3、二叉树的迭代遍历-144，-145，-94" class="headerlink" title="3、二叉树的迭代遍历-144， 145， 94"></a>3、二叉树的迭代遍历-144， 145， 94</h3><p>​    迭代的遍历方法相对来说会更难一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序遍历</span></span><br><span class="line"><span class="comment"># 使用栈存储节点，在存储中间节点数值后，先放入右节点，再放入左节点，这样出栈时才是先左再右</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">        nodes = [root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            node = nodes.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                nodes.append(node.right)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                nodes.append(node.left)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        nodes = []</span><br><span class="line">        cur = root</span><br><span class="line">        <span class="keyword">while</span> nodes <span class="keyword">or</span> cur:</span><br><span class="line">            <span class="keyword">if</span> cur != <span class="literal">None</span>:</span><br><span class="line">                nodes.append(cur)</span><br><span class="line">                cur = cur.left</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = nodes.pop()</span><br><span class="line">                res.append(cur.val)</span><br><span class="line">                cur = cur.right</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 后序遍历</span></span><br><span class="line"><span class="comment"># 前序中左右 -&gt; （调整代码顺序）中右左-&gt;（反转）左右中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">            </span><br><span class="line">        nodes = [root]</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            node = nodes.pop()</span><br><span class="line">            res.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                nodes.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                nodes.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="4、二叉树统一迭代法"><a href="#4、二叉树统一迭代法" class="headerlink" title="4、二叉树统一迭代法"></a>4、二叉树统一迭代法</h3><p>​    为了解决访问节点（遍历节点）和处理节点（将元素放进结果集）不一致的情情况，我们将访问的节点放入栈中，把要处理的节点也放入栈中但是要做标记。如何标记呢，就是要处理的节点放入栈之后，紧接着放入一个空指针作为标记。这种方法也可以叫做<strong>标记法</strong>。</p>
<p>​    我感觉还是直接记统一迭代框架更好一点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">preorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        st= []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 中序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#添加右节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                </span><br><span class="line">                st.append(node) <span class="comment">#添加中节点</span></span><br><span class="line">                st.append(<span class="literal">None</span>) <span class="comment">#中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#添加左节点（空节点不入栈）</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>: <span class="comment">#只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                node = st.pop() <span class="comment">#重新取出栈中元素</span></span><br><span class="line">                result.append(node.val) <span class="comment">#加入到结果集</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="comment"># 后序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">postorderTraversal</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        result = []</span><br><span class="line">        st = []</span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            st.append(root)</span><br><span class="line">        <span class="keyword">while</span> st:</span><br><span class="line">            node = st.pop()</span><br><span class="line">            <span class="keyword">if</span> node != <span class="literal">None</span>:</span><br><span class="line">                st.append(node) <span class="comment">#中</span></span><br><span class="line">                st.append(<span class="literal">None</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> node.right: <span class="comment">#右</span></span><br><span class="line">                    st.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> node.left: <span class="comment">#左</span></span><br><span class="line">                    st.append(node.left)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                node = st.pop()</span><br><span class="line">                result.append(node.val)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="5、二叉树层序遍历-102"><a href="#5、二叉树层序遍历-102" class="headerlink" title="5、二叉树层序遍历-102"></a>5、二叉树层序遍历-102</h3><p>​    学会层序遍历，就可以做102， 107， 199， 637， 429， 515， 116， 117， 104， 111了。</p>
<p>​    这里只写一下层序遍历的模板，具体每道题不同就需要不同的改变了，但主要思想不变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">results = []</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">          <span class="keyword">return</span> results</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">      que = deque([root])</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">while</span> que:</span><br><span class="line">          size = <span class="built_in">len</span>(que)</span><br><span class="line">          result = []</span><br><span class="line">          <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">              cur = que.popleft()</span><br><span class="line">              result.append(cur.val)</span><br><span class="line">              <span class="keyword">if</span> cur.left:</span><br><span class="line">                  que.append(cur.left)</span><br><span class="line">              <span class="keyword">if</span> cur.right:</span><br><span class="line">                  que.append(cur.right)</span><br><span class="line">          results.append(result)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h3 id="6、翻转二叉树-226"><a href="#6、翻转二叉树-226" class="headerlink" title="6、翻转二叉树-226"></a>6、翻转二叉树-226</h3><p>​    <strong>题目</strong>：给你一棵二叉树的根节点 <code>root</code> ，翻转这棵二叉树，并返回其根节点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="comment"># if root.left == None or root.right == None:</span></span><br><span class="line">        <span class="comment">#     return root</span></span><br><span class="line">        </span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="7、对称二叉树-101"><a href="#7、对称二叉树-101" class="headerlink" title="7、对称二叉树-101"></a>7、对称二叉树-101</h3><p>​    <strong>题目</strong>：给定一个二叉树，检查它是否是镜像对称的。</p>
<p>​    1、使用递归的思想，不断比较两边子树是否对称</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compare</span>(<span class="params">self, left, right</span>):</span></span><br><span class="line">        <span class="keyword">if</span> left == <span class="literal">None</span> <span class="keyword">and</span> right ==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> left != <span class="literal">None</span> <span class="keyword">and</span> right ==<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> left == <span class="literal">None</span> <span class="keyword">and</span> right !=<span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left.val != right.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        one = self.compare(left.left, right.right)</span><br><span class="line">        two = self.compare(left.right, right.left)</span><br><span class="line">        <span class="keyword">return</span> one <span class="keyword">and</span> two</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.compare(root.left, root.right)</span><br></pre></td></tr></table></figure>

<p>​    2、使用迭代思想</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isSymmetric</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        nodes = deque([root.left, root.right])</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            l = nodes.popleft()</span><br><span class="line">            r = nodes.popleft()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> l == <span class="literal">None</span> <span class="keyword">and</span> r == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> l == <span class="literal">None</span> <span class="keyword">or</span> r == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> l.val != r.val:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            nodes.append(l.left)</span><br><span class="line">            nodes.append(r.right)</span><br><span class="line">            nodes.append(l.right)</span><br><span class="line">            nodes.append(r.left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="8、二叉树的最大，小深度-104"><a href="#8、二叉树的最大，小深度-104" class="headerlink" title="8、二叉树的最大，小深度-104"></a>8、二叉树的最大，小深度-104</h3><h3 id="9、完全二叉树的节点个数-222"><a href="#9、完全二叉树的节点个数-222" class="headerlink" title="9、完全二叉树的节点个数-222"></a>9、完全二叉树的节点个数-222</h3><p>​    <strong>题目</strong>：给出一个完全二叉树，求出该树的节点个数。</p>
<p>​    在题设情况下如果对于一个树，先一路往左下角走到最底，记录深度，先一路往右下角走到最底，记录深度。如果这两个深度一样，那么这个树就是完全二叉树。这是使用深度计算节点个数能够比遍历所有节点来的更快。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">countNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        left, right = root.left, root.right</span><br><span class="line">        left_depth, right_depth = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left:</span><br><span class="line">            left = left.left</span><br><span class="line">            left_depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> right:</span><br><span class="line">            right = right.right</span><br><span class="line">            right_depth += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> left_depth == right_depth:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> ** (left_depth+<span class="number">1</span>) -<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.countNodes(root.left) + self.countNodes(root.right) + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="10、平衡二叉树-110"><a href="#10、平衡二叉树-110" class="headerlink" title="10、平衡二叉树-110"></a>10、平衡二叉树-110</h3><p>​    <strong>题目</strong>：给定一个二叉树，判断它是否是高度平衡的二叉树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isBalanced</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.get_height(root) != -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_height</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="comment"># Base Case</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># 左</span></span><br><span class="line">        <span class="keyword">if</span> (left_height := self.get_height(root.left)) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 右</span></span><br><span class="line">        <span class="keyword">if</span> (right_height := self.get_height(root.right)) == -<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="comment"># 中</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">abs</span>(left_height - right_height) &gt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(left_height, right_height)</span><br></pre></td></tr></table></figure>

<h3 id="11、二叉树的所有路径-257"><a href="#11、二叉树的所有路径-257" class="headerlink" title="11、二叉树的所有路径-257"></a>11、二叉树的所有路径-257</h3><p>​    <strong>题目</strong>：给定一个二叉树，返回所有从根节点到叶子节点的路径</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> [<span class="built_in">str</span>(root.val)]</span><br><span class="line"></span><br><span class="line">        paths = self.binaryTreePaths(root.left) + self.binaryTreePaths(root.right)</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">str</span>(root.val) + <span class="string">&quot;-&gt;&quot;</span> + i <span class="keyword">for</span> i <span class="keyword">in</span> paths]</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 迭代法</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">binaryTreePaths</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span></span><br><span class="line">        <span class="comment"># 题目中节点数至少为1</span></span><br><span class="line">        stack, path_st, result = deque([root]), deque(), []</span><br><span class="line">        path_st.append(<span class="built_in">str</span>(root.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> stack:</span><br><span class="line">            cur = stack.pop()</span><br><span class="line">            path = path_st.pop()</span><br><span class="line">            <span class="comment"># 如果当前节点为叶子节点，添加路径到结果中</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (cur.left <span class="keyword">or</span> cur.right):</span><br><span class="line">                result.append(path)</span><br><span class="line">            <span class="keyword">if</span> cur.right:</span><br><span class="line">                stack.append(cur.right)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(cur.right.val))</span><br><span class="line">            <span class="keyword">if</span> cur.left:</span><br><span class="line">                stack.append(cur.left)</span><br><span class="line">                path_st.append(path + <span class="string">&#x27;-&gt;&#x27;</span> + <span class="built_in">str</span>(cur.left.val))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h3 id="12、左叶子之和-404"><a href="#12、左叶子之和-404" class="headerlink" title="12、左叶子之和-404"></a>12、左叶子之和-404</h3><p>​    <strong>题目</strong>：给定二叉树的根节点 <code>root</code> ，返回所有左叶子之和</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 迭代</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        res = <span class="number">0</span></span><br><span class="line">        nodes = deque([root])</span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            l = <span class="built_in">len</span>(nodes)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                node = nodes.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nodes.append(node.left)</span><br><span class="line">                    <span class="keyword">if</span> node.left.left == <span class="literal">None</span> <span class="keyword">and</span> node.left.right == <span class="literal">None</span>:</span><br><span class="line">                        res += node.left.val</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nodes.append(node.right)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"><span class="comment"># 递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sumOfLeftLeaves</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        tmp=<span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> root .left <span class="keyword">and</span> root.left.left==<span class="literal">None</span> <span class="keyword">and</span> root.left.right == <span class="literal">None</span>:</span><br><span class="line">            tmp += root.left.val</span><br><span class="line">        <span class="keyword">return</span> self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + tmp</span><br></pre></td></tr></table></figure>

<h3 id="13、找树左下角的值-513"><a href="#13、找树左下角的值-513" class="headerlink" title="13、找树左下角的值-513"></a>13、找树左下角的值-513</h3><p>​    <strong>题目</strong>：给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值</p>
<p>​    使用层序遍历。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findBottomLeftValue</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nodes = deque([root])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> nodes:</span><br><span class="line">            l = <span class="built_in">len</span>(nodes)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(l):</span><br><span class="line">                node = nodes.popleft()</span><br><span class="line">                <span class="keyword">if</span> node.left:</span><br><span class="line">                    nodes.append(node.left)</span><br><span class="line">                <span class="keyword">if</span> node.right:</span><br><span class="line">                    nodes.append(node.right)</span><br><span class="line">                <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                    res = node.val</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="14、路径总和-112"><a href="#14、路径总和-112" class="headerlink" title="14、路径总和-112"></a>14、路径总和-112</h3><p>​    <strong>题目</strong>：给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasPathSum</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode], targetSum: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> root.val == targetSum <span class="keyword">and</span> root.left == <span class="literal">None</span> <span class="keyword">and</span> root.right == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.hasPathSum(root.left, targetSum - root.val) <span class="keyword">or</span> self.hasPathSum(root.right, targetSum - root.val)</span><br></pre></td></tr></table></figure>

<h3 id="15、从中序和后序构造二叉树-106"><a href="#15、从中序和后序构造二叉树-106" class="headerlink" title="15、从中序和后序构造二叉树-106"></a>15、从中序和后序构造二叉树-106</h3><p>​    递归构建左右子树</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">self, inorder: <span class="type">List</span>[<span class="built_in">int</span>], postorder: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val=inorder[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(inorder) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        root_val = postorder[-<span class="number">1</span>]</span><br><span class="line">        idx = inorder.index(root_val)</span><br><span class="line">        left_tree = self.buildTree(inorder[:idx], postorder[:idx])</span><br><span class="line">        right_tree = self.buildTree(inorder[idx+<span class="number">1</span>:], postorder[idx:-<span class="number">1</span>])</span><br><span class="line">        root = TreeNode(val=root_val, left=left_tree, right=right_tree)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="16、最大二叉树-654"><a href="#16、最大二叉树-654" class="headerlink" title="16、最大二叉树-654"></a>16、最大二叉树-654</h3><p>​    这个题连迭代的规则都告诉你了，不迭代就不好意思了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">constructMaximumBinaryTree</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val=nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        root_val = <span class="built_in">max</span>(nums)</span><br><span class="line">        idx = nums.index(root_val)</span><br><span class="line">        root = TreeNode(val=root_val, left=self.constructMaximumBinaryTree(nums[:idx]), right=self.constructMaximumBinaryTree(nums[idx+<span class="number">1</span>:]))</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="17、合并二叉树-617"><a href="#17、合并二叉树-617" class="headerlink" title="17、合并二叉树-617"></a>17、合并二叉树-617</h3><p>​    还是迭代吧</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, root1: TreeNode, root2: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span> <span class="keyword">and</span> root2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> root1 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root2</span><br><span class="line">        <span class="keyword">if</span> root2 == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> root1</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> TreeNode(val=root1.val+root2.val, left=self.mergeTrees(root1.left, root2.left), right=self.mergeTrees(root1.right, root2.right))</span><br></pre></td></tr></table></figure>

<h3 id="18、二叉搜索树中的搜索-700"><a href="#18、二叉搜索树中的搜索-700" class="headerlink" title="18、二叉搜索树中的搜索-700"></a>18、二叉搜索树中的搜索-700</h3><p>​    就是利用二叉搜索树的性质喽</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">while</span> root:</span><br><span class="line">            <span class="keyword">if</span> val == root.val:</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">elif</span> val &gt; root.val:</span><br><span class="line">                root = root.right</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                root = root.left</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="19、验证二叉搜索树-98"><a href="#19、验证二叉搜索树-98" class="headerlink" title="19、验证二叉搜索树-98"></a>19、验证二叉搜索树-98</h3><p>​    <strong>题目</strong>：给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树</p>
<p>​    <strong>二叉搜索树的中序遍历是递增数组。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="comment"># 思路: 利用BST中序遍历的特性.</span></span><br><span class="line">        <span class="comment"># 中序遍历输出的二叉搜索树节点的数值是有序序列</span></span><br><span class="line">        candidate_list = []</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__traverse</span>(<span class="params">root: TreeNode</span>) -&gt; <span class="literal">None</span>:</span> </span><br><span class="line">            <span class="keyword">nonlocal</span> candidate_list</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root: </span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            __traverse(root.left)</span><br><span class="line">            candidate_list.append(root.val)</span><br><span class="line">            __traverse(root.right)</span><br><span class="line">            </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__is_sorted</span>(<span class="params">nums: <span class="built_in">list</span></span>) -&gt; <span class="built_in">bool</span>:</span> </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)): </span><br><span class="line">                <span class="keyword">if</span> nums[i] &lt;= nums[i - <span class="number">1</span>]: <span class="comment"># ⚠️ 注意: Leetcode定义二叉搜索树中不能有重复元素</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        __traverse(root)</span><br><span class="line">        res = __is_sorted(candidate_list)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h3 id="20、二叉搜索树的做小绝对值-530"><a href="#20、二叉搜索树的做小绝对值-530" class="headerlink" title="20、二叉搜索树的做小绝对值-530"></a>20、二叉搜索树的做小绝对值-530</h3><p>​    利用中序遍历递增的性质</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMinimumDifference</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums = []</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trav</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            trav(root.left)</span><br><span class="line">            nums.append(root.val)</span><br><span class="line">            trav(root.right)</span><br><span class="line">        trav(root)</span><br><span class="line">        ret = <span class="number">100000</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>):</span><br><span class="line">            ret = <span class="built_in">min</span>(ret, nums[i+<span class="number">1</span>] - nums[i])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="21、二叉搜索树中的众数-501"><a href="#21、二叉搜索树中的众数-501" class="headerlink" title="21、二叉搜索树中的众数-501"></a>21、二叉搜索树中的众数-501</h3><p>​    <strong>题目</strong>：给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）</p>
<p>​    可以通过中序遍历，然后计数，但是需要O(n)的空间。可以在迭代的同时进行处理，只需O(1)的空间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.max_count = <span class="number">0</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line">        self.pre = <span class="number">10000001</span></span><br><span class="line">        self.ret = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findMode</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trav</span>(<span class="params">root</span>):</span></span><br><span class="line">            <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> </span><br><span class="line">            </span><br><span class="line">            trav(root.left)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> root.val == self.pre:</span><br><span class="line">                self.count += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.count == self.max_count:</span><br><span class="line">                    self.ret.append(self.pre)</span><br><span class="line">                <span class="keyword">elif</span> self.count &gt; self.max_count:</span><br><span class="line">                    self.max_count = self.count</span><br><span class="line">                    self.ret = [self.pre]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.pre = root.val</span><br><span class="line">                self.count = <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self.count == self.max_count:</span><br><span class="line">                    self.ret.append(self.pre)</span><br><span class="line">                <span class="keyword">elif</span> self.count &gt; self.max_count:</span><br><span class="line">                    self.max_count = self.count</span><br><span class="line">                    self.ret = [self.pre]</span><br><span class="line"></span><br><span class="line">            trav(root.right)</span><br><span class="line">        trav(root)</span><br><span class="line">        <span class="keyword">return</span> self.ret</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="22、二叉（搜索）树的最近公共祖先-236"><a href="#22、二叉（搜索）树的最近公共祖先-236" class="headerlink" title="22、二叉（搜索）树的最近公共祖先-236"></a>22、二叉（搜索）树的最近公共祖先-236</h3><p>​    <strong>题目</strong>：给定一个二叉（搜索）树, 找到该树中两个指定节点的最近公共祖先</p>
<h3 id="23、二叉搜索树中的插入操作-701"><a href="#23、二叉搜索树中的插入操作-701" class="headerlink" title="23、二叉搜索树中的插入操作-701"></a>23、二叉搜索树中的插入操作-701</h3><p>​    <strong>题目</strong>：给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。</p>
<p>​    直接插入为二叉搜索树的叶子节点就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insertIntoBST</span>(<span class="params">self, root: TreeNode, val: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val)</span><br><span class="line">        ret = root</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> root.val &gt; val:</span><br><span class="line">                <span class="keyword">if</span> root.left:</span><br><span class="line">                    root = root.left</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    root.left = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> ret</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> root.right:</span><br><span class="line">                    root = root.right</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    root.right = TreeNode(val)</span><br><span class="line">                    <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>

<h3 id="24、删除二叉搜索树中的节点-450"><a href="#24、删除二叉搜索树中的节点-450" class="headerlink" title="24、删除二叉搜索树中的节点-450"></a>24、删除二叉搜索树中的节点-450</h3><p>​    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteNode</span>(<span class="params">self, root: TreeNode, key: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> root  <span class="comment">#第一种情况：没找到删除的节点，遍历到空节点直接返回了</span></span><br><span class="line">        <span class="keyword">if</span> root.val == key:  </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment">#第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</span></span><br><span class="line">                <span class="keyword">del</span> root</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> root.right:  <span class="comment">#第三种情况：其左孩子为空，右孩子不为空，删除节点，右孩子补位 ，返回右孩子为根节点</span></span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.right</span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">if</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right:  <span class="comment">#第四种情况：其右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</span></span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.left</span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">            <span class="keyword">else</span>:  <span class="comment">#第五种情况：左右孩子节点都不为空，则将删除节点的左子树放到删除节点的右子树的最左面节点的左孩子的位置</span></span><br><span class="line">                v = root.right</span><br><span class="line">                <span class="keyword">while</span> v.left:</span><br><span class="line">                    v = v.left</span><br><span class="line">                v.left = root.left</span><br><span class="line">                tmp = root</span><br><span class="line">                root = root.right</span><br><span class="line">                <span class="keyword">del</span> tmp</span><br><span class="line">                <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> root.val &gt; key: root.left = self.deleteNode(root.left,key)</span><br><span class="line">        <span class="keyword">if</span> root.val &lt; key: root.right = self.deleteNode(root.right,key)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h3 id="25、修剪二叉搜索树-669"><a href="#25、修剪二叉搜索树-669" class="headerlink" title="25、修剪二叉搜索树-669"></a>25、修剪二叉搜索树-669</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trimBST</span>(<span class="params">self, root: TreeNode, low: <span class="built_in">int</span>, high: <span class="built_in">int</span></span>) -&gt; TreeNode:</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        确认递归函数参数以及返回值：返回更新后剪枝后的当前root节点</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span></span><br><span class="line">        <span class="comment"># Base Case</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 单层递归逻辑</span></span><br><span class="line">        <span class="keyword">if</span> root.val &lt; low:</span><br><span class="line">            <span class="comment"># 若当前root节点小于左界：只考虑其右子树，用于替代更新后的其本身，抛弃其左子树整体</span></span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.right, low, high)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> high &lt; root.val:</span><br><span class="line">            <span class="comment"># 若当前root节点大于右界：只考虑其左子树，用于替代更新后的其本身，抛弃其右子树整体</span></span><br><span class="line">            <span class="keyword">return</span> self.trimBST(root.left, low, high)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> low &lt;= root.val &lt;= high:</span><br><span class="line">            root.left = self.trimBST(root.left, low, high)</span><br><span class="line">            root.right = self.trimBST(root.right, low, high)</span><br><span class="line">            <span class="comment"># 返回更新后的剪枝过的当前节点root</span></span><br><span class="line">            <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>



<h3 id="26、有序数组专为二叉搜索树-108"><a href="#26、有序数组专为二叉搜索树-108" class="headerlink" title="26、有序数组专为二叉搜索树-108"></a>26、有序数组专为二叉搜索树-108</h3><p>​    迭代就好</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> TreeNode(val=nums[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        split = <span class="built_in">len</span>(nums)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> TreeNode(val=nums[split], left=self.sortedArrayToBST(nums[:split]), right=self.sortedArrayToBST(nums[split+<span class="number">1</span>:]))</span><br></pre></td></tr></table></figure>

<h3 id="27、把二叉搜索树转换为累加树-538"><a href="#27、把二叉搜索树转换为累加树-538" class="headerlink" title="27、把二叉搜索树转换为累加树-538"></a>27、把二叉搜索树转换为累加树-538</h3><p>​    二叉搜索树的中序遍历为升序，倒过来就是降序，然后累加就行了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.num=<span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convertBST</span>(<span class="params">self, root: <span class="type">Optional</span>[TreeNode]</span>) -&gt; <span class="type">Optional</span>[TreeNode]:</span></span><br><span class="line">        <span class="keyword">if</span> root:</span><br><span class="line">            self.convertBST(root.right)</span><br><span class="line"></span><br><span class="line">            root.val = root.val + self.num</span><br><span class="line">            self.num = root.val</span><br><span class="line"></span><br><span class="line">            self.convertBST(root.left)</span><br><span class="line">        <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

  
	</div>
		<footer class="article-footer clearfix">

  <div class="article-tags">
  
  <span></span> <a href="/tags/leetcode刷题/">-- leetcode刷题</a>
  </div>




<div class="article-share" id="share">

  <div data-url="http://example.com/2022/04/06/%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91/" data-title="代码随想录-二叉树 | 放荡小李的博客" data-tsina="" class="share clearfix">
  </div>

</div>
</footer>   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2022/04/06/代码随想录-回溯算法/" title="代码随想录-回溯算法">
  <strong>PREVIOUS:</strong><br/>
  <span>
  代码随想录-回溯算法</span>
</a>
</div>


<div class="next">
<a href="/2022/04/06/代码随想录-栈与队列/"  title="代码随想录-栈与队列">
 <strong>NEXT:</strong><br/> 
 <span>代码随想录-栈与队列
</span>
</a>
</div>

</nav>

	
</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">Contents</strong>
  <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.</span> <span class="toc-text">代码随想录-二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.0.1.</span> <span class="toc-text">1、二叉树理论基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86-144%EF%BC%8C-145%EF%BC%8C-94"><span class="toc-number">1.0.2.</span> <span class="toc-text">2、二叉树的递归遍历-144， 145， 94</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86-144%EF%BC%8C-145%EF%BC%8C-94"><span class="toc-number">1.0.3.</span> <span class="toc-text">3、二叉树的迭代遍历-144， 145， 94</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95"><span class="toc-number">1.0.4.</span> <span class="toc-text">4、二叉树统一迭代法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-102"><span class="toc-number">1.0.5.</span> <span class="toc-text">5、二叉树层序遍历-102</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91-226"><span class="toc-number">1.0.6.</span> <span class="toc-text">6、翻转二叉树-226</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E3%80%81%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91-101"><span class="toc-number">1.0.7.</span> <span class="toc-text">7、对称二叉树-101</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%EF%BC%8C%E5%B0%8F%E6%B7%B1%E5%BA%A6-104"><span class="toc-number">1.0.8.</span> <span class="toc-text">8、二叉树的最大，小深度-104</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E3%80%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0-222"><span class="toc-number">1.0.9.</span> <span class="toc-text">9、完全二叉树的节点个数-222</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E3%80%81%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-110"><span class="toc-number">1.0.10.</span> <span class="toc-text">10、平衡二叉树-110</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84-257"><span class="toc-number">1.0.11.</span> <span class="toc-text">11、二叉树的所有路径-257</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12%E3%80%81%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C-404"><span class="toc-number">1.0.12.</span> <span class="toc-text">12、左叶子之和-404</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13%E3%80%81%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC-513"><span class="toc-number">1.0.13.</span> <span class="toc-text">13、找树左下角的值-513</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14%E3%80%81%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-112"><span class="toc-number">1.0.14.</span> <span class="toc-text">14、路径总和-112</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E3%80%81%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91-106"><span class="toc-number">1.0.15.</span> <span class="toc-text">15、从中序和后序构造二叉树-106</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E3%80%81%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-654"><span class="toc-number">1.0.16.</span> <span class="toc-text">16、最大二叉树-654</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E3%80%81%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91-617"><span class="toc-number">1.0.17.</span> <span class="toc-text">17、合并二叉树-617</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2-700"><span class="toc-number">1.0.18.</span> <span class="toc-text">18、二叉搜索树中的搜索-700</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E3%80%81%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-98"><span class="toc-number">1.0.19.</span> <span class="toc-text">19、验证二叉搜索树-98</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%81%9A%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%80%BC-530"><span class="toc-number">1.0.20.</span> <span class="toc-text">20、二叉搜索树的做小绝对值-530</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0-501"><span class="toc-number">1.0.21.</span> <span class="toc-text">21、二叉搜索树中的众数-501</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E3%80%81%E4%BA%8C%E5%8F%89%EF%BC%88%E6%90%9C%E7%B4%A2%EF%BC%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-236"><span class="toc-number">1.0.22.</span> <span class="toc-text">22、二叉（搜索）树的最近公共祖先-236</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C-701"><span class="toc-number">1.0.23.</span> <span class="toc-text">23、二叉搜索树中的插入操作-701</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E3%80%81%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9-450"><span class="toc-number">1.0.24.</span> <span class="toc-text">24、删除二叉搜索树中的节点-450</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25%E3%80%81%E4%BF%AE%E5%89%AA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-669"><span class="toc-number">1.0.25.</span> <span class="toc-text">25、修剪二叉搜索树-669</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E3%80%81%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%93%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-108"><span class="toc-number">1.0.26.</span> <span class="toc-text">26、有序数组专为二叉搜索树-108</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E3%80%81%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91-538"><span class="toc-number">1.0.27.</span> <span class="toc-text">27、把二叉搜索树转换为累加树-538</span></a></li></ol></li></ol></li></ol>
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			<li><a href="/tags/glioma-segmentation/" title="-- glioma segmentation">-- glioma segmentation<sup>6</sup></a></li>
		
			<li><a href="/tags/leetcode刷题/" title="-- leetcode刷题">-- leetcode刷题<sup>8</sup></a></li>
		
			<li><a href="/tags/tips/" title="-- tips">-- tips<sup>2</sup></a></li>
		
			<li><a href="/tags/tricks/" title="-- tricks">-- tricks<sup>1</sup></a></li>
		
			<li><a href="/tags/比赛/" title="-- 比赛">-- 比赛<sup>1</sup></a></li>
		
			<li><a href="/tags/爬虫/" title="-- 爬虫">-- 爬虫<sup>4</sup></a></li>
		
			<li><a href="/tags/阅读笔记/" title="-- 阅读笔记">-- 阅读笔记<sup>1</sup></a></li>
		
			<li><a href="/tags/glioma-segmentation/" title="--glioma segmentation">--glioma segmentation<sup>1</sup></a></li>
		
			<li><a href="/tags/glioma-segmentation/" title="-glioma segmentation">-glioma segmentation<sup>1</sup></a></li>
		
			<li><a href="/tags/deep-learning/" title="deep learning">deep learning<sup>1</sup></a></li>
		
			<li><a href="/tags/glioma-grading/" title="glioma grading">glioma grading<sup>4</sup></a></li>
		
			<li><a href="/tags/glioma-segmentation/" title="glioma segmentation">glioma segmentation<sup>20</sup></a></li>
		
			<li><a href="/tags/graph-ML/" title="graph ML">graph ML<sup>6</sup></a></li>
		
			<li><a href="/tags/leetcode刷题/" title="leetcode刷题">leetcode刷题<sup>3</sup></a></li>
		
			<li><a href="/tags/medical-image-segmentation/" title="medical image segmentation">medical image segmentation<sup>1</sup></a></li>
		
			<li><a href="/tags/small-tricks/" title="small tricks">small tricks<sup>3</sup></a></li>
		
			<li><a href="/tags/脑肿瘤分割整理/" title="脑肿瘤分割整理">脑肿瘤分割整理<sup>1</sup></a></li>
		
		</ul>
</div>


  <div class="rsspart">
	<a href="" target="_blank" title="rss">RSS</a>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<div class="social-font clearfix">
		
		
		
		
		
	</div>
		<p class="copyright">Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/A-limon/pacman" target="_blank" title="Pacman">Pacman</a> © 2022 
		
		<a href="http://example.com" target="_blank" title="Jiale Li">Jiale Li</a>
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.1.0.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else
    {
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      h  = $('article h2')
      ah = $('article h2'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  if(ah.length==0){
    t.css('display','none');
  }else{
    c.click(function(){
      ta.css('display', 'block').addClass('fadeIn');
    });
    o.click(function(){
      ta.css('display', 'none');
    });
    $(window).scroll(function(){
      ta.css("top",Math.max(140,320-$(this).scrollTop()));
    });
  };
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#share"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="QRcode"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="Weibo"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>






  </body>
</html>
